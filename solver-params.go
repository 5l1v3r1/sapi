// This file presents an interface to SAPI types and functions related to
// solver parameters.  It is generated by the gen-solver-params script
// during "go generate".

package sapi

// #cgo LDFLAGS: -ldwave_sapi
// #include <stdio.h>
// #include <stdlib.h>
// #include <dwave_sapi.h>
import "C"

import (
	"strings"
	"unsafe"
)

// A SolverParameterAnswerMode indicates the format in which we want the solver
// to return solutions.
type SolverParameterAnswerMode int

// These are answer modes a solver can accept.
const (
	AnswerModeHistogram SolverParameterAnswerMode = C.SAPI_ANSWER_MODE_HISTOGRAM
	AnswerModeRaw                                 = C.SAPI_ANSWER_MODE_RAW
)

// Postprocessing indicates the type of postprocessing the solver should
// perform.
type Postprocessing int

// These are the supported types of postprocessing a solver can perform.
const (
	PostprocessNode         Postprocessing = C.SAPI_POSTPROCESS_NONE
	PostprocessSampling                    = C.SAPI_POSTPROCESS_SAMPLING
	PostprocessOptimization                = C.SAPI_POSTPROCESS_OPTIMIZATION
)

// SolverParameters is presented as an interface so the caller does not need to
// use different data structures for the different solver types (quantum
// hardware or the various software solvers).
type SolverParameters interface {
	ToCSolverParameters() *C.sapi_SolverParameters
}

// NewSolverParameters returns an appropriate SolverParameters for the solver
// type.
func (s *Solver) NewSolverParameters() SolverParameters {
	switch {
	case strings.HasSuffix(s.Name, "-sw_optimize"):
		return newSwOptimizeSolverParameters()
	case strings.HasSuffix(s.Name, "-sw_sample"):
		return newSwSampleSolverParameters()
	case strings.HasSuffix(s.Name, "-heuristic"):
		return newSwHeuristicSolverParameters()
	default:
		return newQuantumSolverParameters()
	}
}

// A SwOptimizeSolverParameters represents the parameters that can be passed to
// an optimizing software solver.  It implements the SolverParameters
// interface.
type SwOptimizeSolverParameters struct {
	sosp       C.sapi_SwOptimizeSolverParameters // C version of the parameters
	AnswerMode SolverParameterAnswerMode         // Whether to return individual answers or a histogram
	MaxAnswers int                               // Maximum number of answers to return
	NumReads   int                               // Number of samples to take
}

// newSwOptimizeSolverParameters returns a new SwOptimizeSolverParameters.
func newSwOptimizeSolverParameters() *SwOptimizeSolverParameters {
	cSosp := C.SAPI_SW_OPTIMIZE_SOLVER_DEFAULT_PARAMETERS
	return &SwOptimizeSolverParameters{
		sosp:       cSosp,
		AnswerMode: SolverParameterAnswerMode(cSosp.answer_mode),
		MaxAnswers: int(cSosp.max_answers),
		NumReads:   int(cSosp.num_reads),
	}
}

// ToCSolverParameters converts a SwOptimizeSolverParameters to a
// sapi_SolverParameters.
func (p *SwOptimizeSolverParameters) ToCSolverParameters() *C.sapi_SolverParameters {
	p.sosp.answer_mode = C.sapi_SolverParameterAnswerMode(p.AnswerMode)
	p.sosp.max_answers = C.int(p.MaxAnswers)
	p.sosp.num_reads = C.int(p.NumReads)
	return (*C.sapi_SolverParameters)(unsafe.Pointer(&p.sosp))
}

// A SwSampleSolverParameters represents the parameters that can be passed to a
// sampling software solver.  It implements the SolverParameters interface.
type SwSampleSolverParameters struct {
	sssp          C.sapi_SwSampleSolverParameters // C version of the parameters
	AnswerMode    SolverParameterAnswerMode       // Answer mode
	Beta          float64                         // Boltzmann distribution parameter
	MaxAnswers    int                             // Maximum number of answers to return
	NumReads      int                             // Number of samples to take
	UseRandomSeed bool                            // true if RandomSeed is to be honored
	RandomSeed    uint                            // Seed for the random-number generator
}

// newSwSampleSolverParameters returns a new SwSampleSolverParameters.
func newSwSampleSolverParameters() *SwSampleSolverParameters {
	cSssp := C.SAPI_SW_SAMPLE_SOLVER_DEFAULT_PARAMETERS
	cIntToBool := map[C.int]bool{0: false, 1: true}
	return &SwSampleSolverParameters{
		sssp:          cSssp,
		AnswerMode:    SolverParameterAnswerMode(cSssp.answer_mode),
		Beta:          float64(cSssp.beta),
		MaxAnswers:    int(cSssp.max_answers),
		NumReads:      int(cSssp.num_reads),
		UseRandomSeed: cIntToBool[cSssp.use_random_seed],
		RandomSeed:    uint(cSssp.random_seed),
	}
}

// ToCSolverParameters converts a SwSampleSolverParameters to a
// sapi_SolverParameters.
func (p *SwSampleSolverParameters) ToCSolverParameters() *C.sapi_SolverParameters {
	p.sssp.answer_mode = C.sapi_SolverParameterAnswerMode(p.AnswerMode)
	p.sssp.beta = C.double(p.Beta)
	p.sssp.max_answers = C.int(p.MaxAnswers)
	p.sssp.num_reads = C.int(p.NumReads)
	if p.UseRandomSeed {
		p.sssp.use_random_seed = 1
	} else {
		p.sssp.use_random_seed = 0
	}
	p.sssp.random_seed = C.uint(p.RandomSeed)
	return (*C.sapi_SolverParameters)(unsafe.Pointer(&p.sssp))
}

// A SwHeuristicSolverParameters represents the parameters that can be passed
// to a heuristic software solver.  It implements the SolverParameters
// interface.
type SwHeuristicSolverParameters struct {
	shsp               C.sapi_SwHeuristicSolverParameters // C version of the parameters
	IterationLimit     int                                // Maximum number of solver iterations
	MinBitFlipProb     float64                            // Minimum bit-flip probability
	MaxBitFlipProb     float64                            // Maximum bit-flip probability
	MaxLocalComplexity int                                // Maximum complexity of subgraphs used during local search
	LocalStuckLimit    int                                // Maximum number of consecutive local search steps that do not improve solution quality
	NumPerturbedCopies int                                // Number of perturbed solution copies created at each iteration
	NumVariables       int                                // Lower bound on the number of variables
	UseRandomSeed      bool                               // true if RandomSeed is to be honored
	RandomSeed         uint                               // Seed for the random-number generator
	TimeLimitSeconds   float64                            // Maximum wall-clock time in seconds
}

// newSwHeuristicSolverParameters returns a new SwHeuristicSolverParameters.
func newSwHeuristicSolverParameters() *SwHeuristicSolverParameters {
	cShsp := C.SAPI_SW_HEURISTIC_SOLVER_DEFAULT_PARAMETERS
	cIntToBool := map[C.int]bool{0: false, 1: true}
	return &SwHeuristicSolverParameters{
		shsp:               cShsp,
		IterationLimit:     int(cShsp.iteration_limit),
		MinBitFlipProb:     float64(cShsp.min_bit_flip_prob),
		MaxBitFlipProb:     float64(cShsp.max_bit_flip_prob),
		MaxLocalComplexity: int(cShsp.max_local_complexity),
		LocalStuckLimit:    int(cShsp.local_stuck_limit),
		NumPerturbedCopies: int(cShsp.num_perturbed_copies),
		NumVariables:       int(cShsp.num_variables),
		UseRandomSeed:      cIntToBool[cShsp.use_random_seed],
		RandomSeed:         uint(cShsp.random_seed),
		TimeLimitSeconds:   float64(cShsp.time_limit_seconds),
	}
}

// ToCSolverParameters converts a SwHeuristicSolverParameters to a
// sapi_SolverParameters.
func (p *SwHeuristicSolverParameters) ToCSolverParameters() *C.sapi_SolverParameters {
	p.shsp.iteration_limit = C.int(p.IterationLimit)
	p.shsp.min_bit_flip_prob = C.double(p.MinBitFlipProb)
	p.shsp.max_bit_flip_prob = C.double(p.MaxBitFlipProb)
	p.shsp.max_local_complexity = C.int(p.MaxLocalComplexity)
	p.shsp.local_stuck_limit = C.int(p.LocalStuckLimit)
	p.shsp.num_perturbed_copies = C.int(p.NumPerturbedCopies)
	p.shsp.num_variables = C.int(p.NumVariables)
	if p.UseRandomSeed {
		p.shsp.use_random_seed = 1
	} else {
		p.shsp.use_random_seed = 0
	}
	p.shsp.random_seed = C.uint(p.RandomSeed)
	p.shsp.time_limit_seconds = C.double(p.TimeLimitSeconds)
	return (*C.sapi_SolverParameters)(unsafe.Pointer(&p.shsp))
}

// A QuantumSolverParameters represents the parameters that can be passed to a
// quantum solver.  It implements the SolverParameters interface.
type QuantumSolverParameters struct {
	qsp              C.sapi_QuantumSolverParameters // C version of the parameters
	AnnealingTime    int                            // Annealing time in microseconds
	AnswerMode       SolverParameterAnswerMode      // Whether to return individual answers or a histogram
	AutoScale        bool                           // Scale coefficients to their maximum range
	Beta             float64                        // Boltzmann distribution parameter
	Chains           []int                          // Postprocessing chains
	MaxAnswers       int                            // Maximum number of answers to return
	NumReads         int                            // Number of samples to take
	NumSpinReversals int                            // Number of spin-reversal transformations to perform
	Postprocess      Postprocessing                 // Type of classical postprocessing to perform
	ProgTherm        int                            // Post-programming thermalization time in microseconds
	ReadoutTherm     int                            // Post-readout thermalization time in microseconds
	AnnealOffsets    []float64                      // Per-qubit amount to offset annealing paths
}

// newQuantumSolverParameters returns a new QuantumSolverParameters.
func newQuantumSolverParameters() *QuantumSolverParameters {
	cQsp := C.SAPI_QUANTUM_SOLVER_DEFAULT_PARAMETERS
	cIntToBool := map[C.int]bool{0: false, 1: true}
	return &QuantumSolverParameters{
		qsp:              cQsp,
		AnswerMode:       SolverParameterAnswerMode(cQsp.answer_mode),
		AutoScale:        cIntToBool[cQsp.auto_scale],
		Beta:             float64(cQsp.beta),
		Chains:           nil,
		MaxAnswers:       int(cQsp.max_answers),
		NumReads:         int(cQsp.num_reads),
		NumSpinReversals: int(cQsp.num_spin_reversal_transforms),
		Postprocess:      Postprocessing(cQsp.postprocess),
		ProgTherm:        int(cQsp.programming_thermalization),
		ReadoutTherm:     int(cQsp.readout_thermalization),
		AnnealOffsets:    nil,
	}
}

// convertChainsToGo converts the list of chains from Go to C.
func (p *QuantumSolverParameters) convertChainsToGo() {
	cs := p.Chains
	if len(cs) == 0 {
		p.qsp.chains = nil
		return
	}
	nc := C.size_t(len(cs))
	chains := (*C.sapi_Chains)(C.malloc(C.sizeof_sapi_Chains))
	chains.len = nc
	elts := C.malloc(C.sizeof_int * nc)
	ePtr := (*[1 << 30]C.int)(elts)[:nc:nc]
	for i, c := range cs {
		ePtr[i] = C.int(c)
	}
	chains.elements = (*C.int)(elts)
	p.qsp.chains = chains
}

// convertAnnealOffsetsToGo converts the list of per-qubit anneal offsets from
// C to Go.
func (p *QuantumSolverParameters) convertAnnealOffsetsToGo() {
	ao := p.AnnealOffsets
	if len(ao) == 0 {
		p.qsp.anneal_offsets = nil
		return
	}
	na := C.size_t(len(ao))
	ofs := (*C.sapi_AnnealOffsets)(C.malloc(C.sizeof_sapi_AnnealOffsets))
	ofs.len = na
	elts := C.malloc(C.sizeof_double * na)
	ePtr := (*[1 << 30]C.double)(elts)[:na:na]
	for i, o := range ao {
		ePtr[i] = C.double(o)
	}
	ofs.elements = (*C.double)(elts)
	p.qsp.anneal_offsets = ofs
}

// ToCSolverParameters converts a QuantumSolverParameters to a
// sapi_SolverParameters.
func (p *QuantumSolverParameters) ToCSolverParameters() *C.sapi_SolverParameters {
	p.qsp.answer_mode = C.sapi_SolverParameterAnswerMode(p.AnswerMode)
	if p.AutoScale {
		p.qsp.auto_scale = 1
	} else {
		p.qsp.auto_scale = 0
	}
	p.qsp.beta = C.double(p.Beta)
	p.convertChainsToGo()
	p.qsp.max_answers = C.int(p.MaxAnswers)
	p.qsp.num_reads = C.int(p.NumReads)
	p.qsp.num_spin_reversal_transforms = C.int(p.NumSpinReversals)
	p.qsp.postprocess = C.sapi_Postprocess(p.Postprocess)
	p.qsp.programming_thermalization = C.int(p.ProgTherm)
	p.qsp.readout_thermalization = C.int(p.ReadoutTherm)
	p.convertAnnealOffsetsToGo()
	return (*C.sapi_SolverParameters)(unsafe.Pointer(&p.qsp))
}
