#! /usr/bin/env perl

#############################
# Generate solver-params.go #
#############################

# Much of solver-params.go is repetitive code.  We therefore generate what we
# can to reduce the likelihood of mistakes.

use warnings;
use strict;

# Map each supported solver type to various tags it uses.
my %solvers = (
    "samp" => ["SwSampleSolverParameters",    "sssp", "SW_SAMPLE"],
    "opt"  => ["SwOptimizeSolverParameters",  "sosp", "SW_OPTIMIZE"],
    "heur" => ["SwHeuristicSolverParameters", "shsp", "SW_HEURISTIC"],
    "hw"   => ["QuantumSolverParameters",     "qsp",  "QUANTUM"]);
my @solver_types = qw(samp opt heur hw);

# generate_method produces Go code from a list of solvers and a template.
# Solvers not appearing in the list produce code with an empty body.
sub generate_method (@) {
    my $full_template = pop;
    my $stub_template = $full_template;
    my %full_solvers = map {$_ => 1} @_;
    $stub_template =~ s/\{.*\}/\{\n\}/gs;
    $stub_template =~ s!^func!//\n// For [STRUCT], this method is a no-op.\nfunc!gm;
    foreach my $type (@solver_types) {
	my ($struct, $field, $const) = @{$solvers{$type}};
	my $code = defined $full_solvers{$type} ? $full_template : $stub_template;
	$code =~ s/\[STRUCT\]/$struct/g;
	$code =~ s/\[FIELD\]/$field/g;
	$code =~ s/\[CONST\]/$const/g;
	print $code, "\n";
    }
}

# Output some stock header code.
print <<'HEADER';
// This file presents an interface to SAPI types and functions related to
// solver parameters.  It is generated by the gen-solver-params script
// during "go generate".

package sapi

// #cgo LDFLAGS: -ldwave_sapi
// #include <stdio.h>
// #include <stdlib.h>
// #include <dwave_sapi.h>
import "C"

import (
	"strings"
	"unsafe"
)

// A SolverParameterAnswerMode indicates the format in which we want the solver
// to return solutions.
type SolverParameterAnswerMode int

// These are answer modes a solver can accept.
const (
	AnswerModeHistogram SolverParameterAnswerMode = C.SAPI_ANSWER_MODE_HISTOGRAM
	AnswerModeRaw                                 = C.SAPI_ANSWER_MODE_RAW
)

// Postprocessing indicates the type of postprocessing the solver should perform.
type Postprocessing int

// These are the supported types of postprocessing a solver can perform.
const (
	PostprocessNode         Postprocessing = C.SAPI_POSTPROCESS_NONE
	PostprocessSampling                    = C.SAPI_POSTPROCESS_SAMPLING
	PostprocessOptimization                = C.SAPI_POSTPROCESS_OPTIMIZATION
)

// SolverParameters is presented as an interface so the caller does not need to
// use different data structures for the different solver types (quantum or the
// various software solvers).
type SolverParameters interface {
	SetAnnealingTime(at int)
	SetAnswerMode(m SolverParameterAnswerMode)
	SetAutoScale(y bool)
	SetBeta(b float64)
	SetChains(cs []int)
	SetMaxAnswers(ma int)
	SetNumReads(nr int)
	SetNumSpinReversals(sr int)
	SetPostprocessing(pp Postprocessing)
	SetProgTherm(pt int)
	SetReadoutTherm(rt int)
	ToC() *C.sapi_SolverParameters
}

// NewSolverParameters returns an appropriate SolverParameters for the solver
// type.
func (s *Solver) NewSolverParameters() SolverParameters {
	switch {
	case strings.HasSuffix(s.Name, "-sw_optimize"):
		return NewSwOptimizeSolverParameters()
	case strings.HasSuffix(s.Name, "-sw_sample"):
		return NewSwSampleSolverParameters()
	case strings.HasSuffix(s.Name, "-heuristic"):
		return NewSwHeuristicSolverParameters()
	default:
		return NewQuantumSolverParameters()
	}
}

// A SwSampleSolverParameters represents the parameters that can be passed to a
// sampling software solver.  It implements the SolverParameters interface.
type SwSampleSolverParameters struct {
	sssp C.sapi_SwSampleSolverParameters
}

// A SwOptimizeSolverParameters represents the parameters that can be passed to
// an optimizing software solver.  It implements the SolverParameters
// interface.
type SwOptimizeSolverParameters struct {
	sosp C.sapi_SwOptimizeSolverParameters
}

// A SwHeuristicSolverParameters represents the parameters that can be passed
// to a heuristic software solver.  It implements the SolverParameters
// interface.
type SwHeuristicSolverParameters struct {
	shsp C.sapi_SwHeuristicSolverParameters
}

// A QuantumSolverParameters represents the parameters that can be passed to a
// quantum solver.  It implements the SolverParameters interface.
type QuantumSolverParameters struct {
	qsp C.sapi_QuantumSolverParameters
}

HEADER
;

generate_method(qw(samp opt heur hw), <<'NEW');
// New[STRUCT] returns a new [STRUCT].
func New[STRUCT]() *[STRUCT] {
	return &[STRUCT]{
		[FIELD]: C.SAPI_[CONST]_SOLVER_DEFAULT_PARAMETERS,
	}
}
NEW
;

generate_method("hw", <<'ANN_TIME');
// SetAnnealingTime specifies the annealing time in microseconds.
func (p *[STRUCT]) SetAnnealingTime(at int) {
	p.[FIELD].annealing_time = C.int(at)
}
ANN_TIME
;

generate_method(qw(samp opt hw), <<'ANS_MODE');
// SetAnswerMode specifies the form in which we want to see the solver's output.
func (p *[STRUCT]) SetAnswerMode(m SolverParameterAnswerMode) {
	p.[FIELD].answer_mode = C.sapi_SolverParameterAnswerMode(m)
}
ANS_MODE
;

generate_method("hw", <<'AUTO_SCALE');
// SetAutoScale specifies whether coefficients should be automatically scaled.
func (p *[STRUCT]) SetAutoScale(y bool) {
	if y {
		p.[FIELD].auto_scale = 1
	} else {
		p.[FIELD].auto_scale = 0
	}
}
AUTO_SCALE
;

generate_method(qw(samp hw), <<'BETA');
// SetBeta specifies the Boltzmann distribution parameter.
func (p *[STRUCT]) SetBeta(b float64) {
	p.[FIELD].beta = C.double(b)
}
BETA
;

generate_method("hw", <<'CHAINS');
// SetChains indicates where all the chains lie.  The value of c[i] means c[i]
// contains qubit i; -1 means a singleton chain.
func (p *[STRUCT]) SetChains(cs []int) {
	if len(cs) == 0 {
		p.[FIELD].chains = nil
		return
	}
	nc := C.size_t(len(cs))
	chains := (*C.sapi_Chains)(C.malloc(C.sizeof_sapi_Chains))
	chains.len = nc
	elts := C.malloc(C.sizeof_int * nc)
	ePtr := (*[1 << 30]C.int)(elts)[:nc:nc]
	for i, c := range cs {
		ePtr[i] = C.int(c)
	}
	chains.elements = (*C.int)(elts)
	p.[FIELD].chains = chains
}
CHAINS
;

generate_method(qw(samp opt hw), <<'MAX_ANS');
// SetMaxAnswers specifies the maximum number of answers the solver should
// return.
func (p *[STRUCT]) SetMaxAnswers(ma int) {
	p.[FIELD].max_answers = C.int(ma)
}
MAX_ANS
;

generate_method(qw(samp opt hw), <<'NUM_READS');
// SetNumReads specifies the number of reads to take.
func (p *[STRUCT]) SetNumReads(nr int) {
	p.[FIELD].num_reads = C.int(nr)
}
NUM_READS
;

generate_method("hw", <<'SPIN_REVS');
// SetNumSpinReversals specifies the number of spin-reversal transformations to
// perform.
func (p *[STRUCT]) SetNumSpinReversals(sr int) {
	p.[FIELD].num_spin_reversal_transforms = C.int(sr)
}
SPIN_REVS
;

generate_method("hw", <<'POSTPROC');
// SetPostprocessing requests the the solver's output be postprocessed.
func (p *[STRUCT]) SetPostprocessing(pp Postprocessing) {
	p.[FIELD].postprocess = C.sapi_Postprocess(pp)
}
POSTPROC
;

generate_method("hw", <<'PROG_THERM');
// SetProgTherm specifies the time in microseconds to wait after programming
// the quantum processor in order for it to cool back to base temperature.
func (p *[STRUCT]) SetProgTherm(pt int) {
	p.[FIELD].programming_thermalization = C.int(pt)
}
PROG_THERM
;

generate_method("hw", <<'READ_THERM');
// SetReadoutTherm specifies the time in microseconds to wait after each state
// is read from the quantum processor in order for it to cool back to base
// temperature.
func (p *[STRUCT]) SetReadoutTherm(pt int) {
	p.[FIELD].readout_thermalization = C.int(pt)
}
READ_THERM
;

generate_method(qw(samp opt heur hw), <<'TOC');
// ToC converts a [STRUCT] to a sapi_SolverParameters.
func (p *[STRUCT]) ToC() *C.sapi_SolverParameters {
	return (*C.sapi_SolverParameters)(unsafe.Pointer(&p.[FIELD]))
}
TOC
;
